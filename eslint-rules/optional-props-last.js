/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 24, 2025
 */

/**
 * ESLint правило для проверки порядка свойств в интерфейсах и типах TypeScript
 * 
 * Требуемый порядок:
 * 1. Обязательные члены (не функции)
 * 2. Необязательные члены (не функции) 
 * 3. Обязательные члены-функции
 * 4. Необязательные члены-функции
 */

export default {
    meta: {
        type: "problem",
        docs: {
            description: "Требует, чтобы опциональные свойства располагались после обязательных",
            category: "Stylistic Issues",
            recommended: false,
        },
        fixable: null,
        schema: [],
        messages: {
            wrongMemberOrder: "Член '{{memberName}}' ({{currentType}}) должен располагаться {{direction}} {{expectedType}} членов",
        },
    },

    create(context) {
        /**
         * Определяет тип члена для сортировки
         * @param {Object} member - AST узел члена
         * @returns {Object} информация о типе члена
         */
        function getMemberInfo(member) {
            const isOptional = member.optional === true;
            const isFunction = isFunctionMember(member);

            let order, typeDescription;

            if (!isFunction && !isOptional) {
                order = 1;
                typeDescription = "обязательных не-функций";
            } else if (!isFunction && isOptional) {
                order = 2;
                typeDescription = "необязательных не-функций";
            } else if (isFunction && !isOptional) {
                order = 3;
                typeDescription = "обязательных функций";
            } else { // isFunction && isOptional
                order = 4;
                typeDescription = "необязательных функций";
            }

            return { order, typeDescription, isOptional, isFunction };
        }

        /**
         * Проверяет, является ли член функцией
         * @param {Object} member - AST узел члена
         * @returns {boolean}
         */
        function isFunctionMember(member) {
            // Методы всегда функции
            if (member.type === "TSMethodSignature") {
                return true;
            }

            // Для свойств проверяем тип аннотации
            if (member.type === "TSPropertySignature" && member.typeAnnotation) {
                const typeAnnotation = member.typeAnnotation.typeAnnotation;

                // Функциональный тип: () => void, (param: type) => ReturnType
                if (typeAnnotation.type === "TSFunctionType") {
                    return true;
                }

                // Стрелочная функция: ActionFn, Handler, etc.
                if (typeAnnotation.type === "TSTypeReference") {
                    const typeName = typeAnnotation.typeName;
                    if (typeName.type === "Identifier") {
                        // Эвристика: если тип содержит Fn, Handler, Action, Callback - вероятно функция
                        const name = typeName.name;
                        return /^(Action|Handler|Callback|Fn|Function)/.test(name) ||
                            /(Fn|Handler|Action|Callback|Function)$/.test(name);
                    }
                }
            }

            return false;
        }

        /**
         * Проверяет порядок свойств в интерфейсе или типе
         * @param {Array} members - массив свойств
         */
        function checkMembersOrder(members) {
            const properties = members.filter(member =>
                member.type === "TSPropertySignature" ||
                member.type === "TSMethodSignature"
            );

            // Проверяем порядок каждого члена
            for (let i = 0; i < properties.length; i++) {
                const currentMember = properties[i];
                const currentInfo = getMemberInfo(currentMember);

                // Проверяем все последующие члены
                for (let j = i + 1; j < properties.length; j++) {
                    const nextMember = properties[j];
                    const nextInfo = getMemberInfo(nextMember);

                    // Если порядок нарушен (следующий член должен идти раньше текущего)
                    if (nextInfo.order < currentInfo.order) {
                        const memberName = getPropertyName(currentMember);

                        context.report({
                            node: currentMember,
                            messageId: "wrongMemberOrder",
                            data: {
                                memberName,
                                currentType: currentInfo.typeDescription,
                                direction: "после",
                                expectedType: nextInfo.typeDescription
                            },
                        });
                        break; // Сообщаем только об одной ошибке для каждого члена
                    }
                }
            }
        }

        /**
         * Получает имя свойства
         * @param {Object} member - узел свойства
         * @returns {string} имя свойства
         */
        function getPropertyName(member) {
            if (member.key) {
                if (member.key.type === "Identifier") {
                    return member.key.name;
                }
                if (member.key.type === "Literal") {
                    return String(member.key.value);
                }
                if (member.key.type === "TemplateElement") {
                    return member.key.value.raw;
                }
            }
            return "<unknown>";
        }

        return {
            // Проверяем интерфейсы
            TSInterfaceDeclaration(node) {
                checkMembersOrder(node.body.body);
            },

            // Проверяем типы объектов
            TSTypeLiteral(node) {
                checkMembersOrder(node.members);
            },
        };
    },
};

/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 24, 2025
 */

/**
 * ESLint rule: hooks-order
 *
 * Проверяет правильный порядок хуков в React компонентах согласно правилам проекта:
 * 1. Хуки, связанные с навигацией (useLocation, useParams, useNavigate, etc.)
 * 2. Хуки, связанные с состоянием (useState, useReducer)
 * 3. Хуки, связанные с меморизацией значений (useMemo, useRef)
 * 4. Хуки, связанные с меморизированными функциями (useCallback)
 * 5. Хуки, связанные с эффектами (useEffect, useLayoutEffect, useMount, etc.)
 */

export default {
  meta: {
    type: "problem",
    docs: {
      description: "Enforce hooks to be ordered by their type according to project guidelines",
      category: "Stylistic Issues",
      recommended: false
    },
    fixable: null,
    schema: [],
    messages: {
      wrongHookOrder: "Hook '{{hookName}}' ({{currentCategory}}) should come {{direction}} {{expectedCategory}} hooks",
    },
  },

  create(context) {
    // Категории хуков в порядке приоритета
    const HOOK_CATEGORIES = {
      navigation: {
        order: 1,
        name: "navigation",
        displayName: "навигационных",
        hooks: [
          "useLocation",
          "useParams",
          "useNavigate",
          "useSearchParams",
          "useHistory",
          "useRouteMatch",
          "useMatch",
          "useResolvedPath"
        ]
      },
      state: {
        order: 2,
        name: "state",
        displayName: "состояния",
        hooks: [
          "useState",
          "useReducer",
          "useContext"
        ]
      },
      memoization: {
        order: 3,
        name: "memoization",
        displayName: "меморизации значений",
        hooks: [
          "useMemo",
          "useRef",
          "useId",
          "useImperativeHandle"
        ]
      },
      callbacks: {
        order: 4,
        name: "callbacks",
        displayName: "меморизированных функций",
        hooks: [
          "useCallback"
        ]
      },
      effects: {
        order: 5,
        name: "effects",
        displayName: "эффектов",
        hooks: [
          "useEffect",
          "useLayoutEffect",
          "useMount",
          "useUnmount",
          "useUpdateEffect",
          "useAsyncEffect"
        ]
      }
    };

    /**
     * Определяет категорию хука по его имени
     * @param {string} hookName - имя хука
     * @returns {Object|null} категория хука или null если хук не найден
     */
    function getHookCategory(hookName) {
      for (const category of Object.values(HOOK_CATEGORIES)) {
        if (category.hooks.includes(hookName)) {
          return category;
        }
      }
      return null;
    }

    /**
     * Проверяет, является ли узел вызовом хука
     * @param {Object} node - AST узел
     * @returns {boolean}
     */
    function isHookCall(node) {
      if (node.type !== "CallExpression") return false;

      const callee = node.callee;
      if (callee.type === "Identifier") {
        return callee.name.startsWith("use") && callee.name.length > 3;
      }

      return false;
    }

    /**
     * Получает все хуки из тела функционального компонента
     * @param {Array} statements - массив выражений функции
     * @returns {Array} массив объектов с информацией о хуках
     */
    function getHooksFromStatements(statements) {
      const hooks = [];

      for (const statement of statements) {
        if (statement.type === "VariableDeclaration") {
          for (const declarator of statement.declarations) {
            if (declarator.init && isHookCall(declarator.init)) {
              const hookName = declarator.init.callee.name;
              const category = getHookCategory(hookName);

              if (category) {
                hooks.push({
                  node: declarator.init,
                  name: hookName,
                  category: category,
                  line: statement.loc.start.line
                });
              }
            }
          }
        } else if (statement.type === "ExpressionStatement" && isHookCall(statement.expression)) {
          const hookName = statement.expression.callee.name;
          const category = getHookCategory(hookName);

          if (category) {
            hooks.push({
              node: statement.expression,
              name: hookName,
              category: category,
              line: statement.loc.start.line
            });
          }
        }
      }

      return hooks;
    }

    /**
     * Проверяет порядок хуков и сообщает об ошибках
     * @param {Array} hooks - массив хуков для проверки
     */
    function checkHooksOrder(hooks) {
      if (hooks.length <= 1) return;

      for (let i = 1; i < hooks.length; i++) {
        const currentHook = hooks[i];
        const previousHook = hooks[i - 1];

        // Проверяем, что текущий хук не идет раньше предыдущего по приоритету
        if (currentHook.category.order < previousHook.category.order) {
          const direction = "после";
          context.report({
            node: currentHook.node,
            messageId: "wrongHookOrder",
            data: {
              hookName: currentHook.name,
              currentCategory: currentHook.category.displayName,
              direction: direction,
              expectedCategory: previousHook.category.displayName
            }
          });
        }
      }
    }

    return {
      // Проверяем функциональные компоненты (объявления функций)
      FunctionDeclaration(node) {
        // Проверяем, что это React компонент (начинается с заглавной буквы)
        if (node.id && node.id.name && /^[A-Z]/.test(node.id.name)) {
          const hooks = getHooksFromStatements(node.body.body);
          checkHooksOrder(hooks);
        }
      },

      // Проверяем стрелочные функции в переменных (const Component = () => {})
      VariableDeclaration(node) {
        for (const declarator of node.declarations) {
          if (declarator.id &&
            declarator.id.name &&
            /^[A-Z]/.test(declarator.id.name) &&
            declarator.init &&
            (declarator.init.type === "ArrowFunctionExpression" ||
              declarator.init.type === "FunctionExpression")) {

            if (declarator.init.body.type === "BlockStatement") {
              const hooks = getHooksFromStatements(declarator.init.body.body);
              checkHooksOrder(hooks);
            }
          }
        }
      }
    };
  }
};

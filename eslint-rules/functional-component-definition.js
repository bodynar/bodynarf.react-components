/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 24, 2025
 */

/**
 * ESLint rule: functional-component-definition
 *
 * Требует использования функционального подхода для React компонентов согласно п.6 документации:
 * "Для компонентов необходимо использовать функциональный подход и описывать их как 
 * константы с типизацией FC или FC<Props>"
 *
 * Правильно:
 * - const MyComponent: FC<Props> = (props) => { return <div />; }
 * - const MyComponent: FC = () => { return <div />; }
 *
 * Неправильно:
 * - function MyComponent(props) { return <div />; }
 * - function MyComponent(): JSX.Element { return <div />; }
 */

export default {
  meta: {
    type: "problem",
    docs: {
      description: "Enforce functional approach for React components using const with FC typing",
      category: "Best Practices",
      recommended: true
    },
    fixable: null,
    schema: [],
    messages: {
      useFunctionalComponent: "Component '{{componentName}}' should be defined as const with FC typing instead of function declaration. Use: const {{componentName}}: FC{{genericType}} = {{params}} => { ... }",
      missingFCTyping: "Component '{{componentName}}' should use FC or FC<Props> typing",
      preferArrowFunction: "Component '{{componentName}}' should use arrow function syntax with FC typing"
    },
  },

  create(context) {
    /**
     * Проверяет, является ли имя именем React компонента (начинается с заглавной буквы)
     * @param {string} name - имя функции/переменной
     * @returns {boolean}
     */
    function isComponentName(name) {
      return name && /^[A-Z]/.test(name);
    }

    /**
     * Проверяет, имеет ли переменная типизацию FC
     * @param {Object} node - AST узел объявления переменной
     * @returns {boolean}
     */
    function hasFCTyping(node) {
      if (!node.id || !node.id.typeAnnotation) return false;

      const typeAnnotation = node.id.typeAnnotation.typeAnnotation;

      // Проверяем TSTypeReference (FC или FC<Props>)
      if (typeAnnotation.type === "TSTypeReference") {
        const typeName = typeAnnotation.typeName;

        // Простое FC
        if (typeName.type === "Identifier" && typeName.name === "FC") {
          return true;
        }

        // Qualified name типа React.FC
        if (typeName.type === "TSQualifiedName" &&
          typeName.right.name === "FC") {
          return true;
        }
      }

      return false;
    }

    /**
     * Проверяет, является ли функция компонентом по её содержимому
     * @param {Object} functionNode - AST узел функции
     * @returns {boolean}
     */
    function looksLikeComponent(functionNode) {
      if (!functionNode.body || functionNode.body.type !== "BlockStatement") {
        return false;
      }

      // Ищем return statement с JSX
      for (const statement of functionNode.body.body) {
        if (statement.type === "ReturnStatement" && statement.argument) {
          return hasJSXElements(statement.argument);
        }
      }

      return false;
    }

    /**
     * Проверяет, содержит ли выражение JSX элементы
     * @param {Object} node - AST узел
     * @returns {boolean}
     */
    function hasJSXElements(node) {
      if (!node) return false;

      // Прямой JSX элемент
      if (node.type === "JSXElement" || node.type === "JSXFragment") {
        return true;
      }

      // JSX в скобках
      if (node.type === "JSXExpressionContainer") {
        return hasJSXElements(node.expression);
      }

      // Условные выражения
      if (node.type === "ConditionalExpression") {
        return hasJSXElements(node.consequent) || hasJSXElements(node.alternate);
      }

      // Логические выражения
      if (node.type === "LogicalExpression") {
        return hasJSXElements(node.left) || hasJSXElements(node.right);
      }

      return false;
    }

    /**
     * Получает строку с параметрами функции для сообщения об ошибке
     * @param {Object} functionNode - AST узел функции
     * @returns {string}
     */
    function getParamsString(functionNode) {
      if (!functionNode.params || functionNode.params.length === 0) {
        return "()";
      }

      // Упрощенная версия - просто показываем, что есть параметры
      return functionNode.params.length === 1 ? "(props)" : "(props)";
    }

    /**
     * Получает строку с дженериком для FC типизации
     * @param {Object} functionNode - AST узел функции
     * @returns {string}
     */
    function getGenericType(functionNode) {
      // Если функция имеет параметры, предполагаем что нужен дженерик
      if (functionNode.params && functionNode.params.length > 0) {
        const firstParam = functionNode.params[0];
        if (firstParam.typeAnnotation) {
          return "<Props>";
        }
      }
      return "";
    }

    return {
      // Проверяем объявления функций
      FunctionDeclaration(node) {
        if (node.id && isComponentName(node.id.name)) {
          // Проверяем, что функция действительно выглядит как React компонент
          if (looksLikeComponent(node)) {
            const componentName = node.id.name;
            const paramsString = getParamsString(node);
            const genericType = getGenericType(node);

            context.report({
              node: node,
              messageId: "useFunctionalComponent",
              data: {
                componentName,
                genericType,
                params: paramsString
              }
            });
          }
        }
      },

      // Проверяем переменные с компонентами
      VariableDeclaration(node) {
        for (const declarator of node.declarations) {
          if (declarator.id &&
            declarator.id.name &&
            isComponentName(declarator.id.name)) {

            // Проверяем, что это функция (стрелочная или обычная)
            const init = declarator.init;
            if (init &&
              (init.type === "ArrowFunctionExpression" ||
                init.type === "FunctionExpression")) {

              // Проверяем, что это действительно компонент
              if (looksLikeComponent(init)) {
                // Проверяем типизацию FC
                if (!hasFCTyping(declarator)) {
                  context.report({
                    node: declarator,
                    messageId: "missingFCTyping",
                    data: {
                      componentName: declarator.id.name
                    }
                  });
                }
              }
            }
          }
        }
      }
    };
  }
};

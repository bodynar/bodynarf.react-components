/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 24, 2025
 */

/**
 * ESLint rule: no-duplicate-imports
 *
 * Запрещает несколько импортов из одного модуля согласно п.III.3 документации:
 * "На каждый импортируемый модуль должна быть 1 строка. Т.е. запрещено иметь строки вида 
 * [import React from "react", import { FC } from "react"], в таком случае правильней будет 
 * import React, { FC } from "react""
 *
 * Правильно:
 * - import React, { FC, useState } from "react"
 * - import { Button, Modal } from "@bodynarf/react.components"
 *
 * Неправильно:
 * - import React from "react"; import { FC } from "react"
 * - import { Button } from "@bodynarf/react.components"; import { Modal } from "@bodynarf/react.components"
 */

export default {
  meta: {
    type: "problem",
    docs: {
      description: "Prevent multiple import declarations from the same module",
      category: "Best Practices",
      recommended: true
    },
    fixable: "code",
    schema: [],
    messages: {
      duplicateImport: "Multiple imports from '{{module}}' should be combined into a single import statement",
      combineImports: "Combine these imports: {{suggestions}}"
    },
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const importMap = new Map(); // модуль -> массив импортов

    /**
     * Собирает информацию об импорте
     * @param {Object} node - AST узел ImportDeclaration
     * @returns {Object} информация об импорте
     */
    function getImportInfo(node) {
      const source = node.source.value;
      const specifiers = {
        default: null,
        namespace: null,
        named: []
      };

      for (const spec of node.specifiers) {
        if (spec.type === "ImportDefaultSpecifier") {
          specifiers.default = spec.local.name;
        } else if (spec.type === "ImportNamespaceSpecifier") {
          specifiers.namespace = spec.local.name;
        } else if (spec.type === "ImportSpecifier") {
          specifiers.named.push({
            imported: spec.imported.name,
            local: spec.local.name
          });
        }
      }

      return {
        node,
        source,
        specifiers,
        line: node.loc.start.line
      };
    }

    /**
     * Генерирует строку предложения для объединенного импорта
     * @param {Array} imports - массив импортов из одного модуля
     * @returns {string} строка с объединенным импортом
     */
    function generateCombinedImport(imports) {
      const source = imports[0].source;
      const parts = [];

      // Собираем все типы импортов
      let defaultImport = null;
      let namespaceImport = null;
      const namedImports = [];

      for (const imp of imports) {
        if (imp.specifiers.default) {
          defaultImport = imp.specifiers.default;
        }
        if (imp.specifiers.namespace) {
          namespaceImport = imp.specifiers.namespace;
        }
        namedImports.push(...imp.specifiers.named);
      }

      // Формируем строку импорта
      if (defaultImport) {
        parts.push(defaultImport);
      }

      if (namespaceImport) {
        parts.push(`* as ${namespaceImport}`);
      }

      if (namedImports.length > 0) {
        // Убираем дубликаты named импортов
        const uniqueNamed = namedImports.filter((item, index, arr) =>
          arr.findIndex(i => i.imported === item.imported && i.local === item.local) === index
        );

        const namedStr = uniqueNamed
          .map(spec => spec.imported === spec.local ? spec.imported : `${spec.imported} as ${spec.local}`)
          .join(", ");

        parts.push(`{ ${namedStr} }`);
      }

      return `import ${parts.join(", ")} from "${source}";`;
    }

    /**
     * Проверяет и сообщает о дублирующихся импортах
     */
    function checkDuplicateImports() {
      for (const [module, imports] of importMap) {
        if (imports.length > 1) {
          const combinedSuggestion = generateCombinedImport(imports);

          // Сообщаем об ошибке для каждого дублирующегося импорта (кроме первого)
          for (let i = 1; i < imports.length; i++) {
            context.report({
              node: imports[i].node,
              messageId: "duplicateImport",
              data: {
                module: module
              },
              fix(fixer) {
                const fixes = [];

                // Удаляем все импорты кроме первого
                for (let j = 1; j < imports.length; j++) {
                  fixes.push(fixer.remove(imports[j].node));
                }

                // Заменяем первый импорт на объединенный
                fixes.push(fixer.replaceText(imports[0].node, combinedSuggestion));

                return fixes;
              }
            });
          }
        }
      }
    }

    return {
      ImportDeclaration(node) {
        const importInfo = getImportInfo(node);
        const source = importInfo.source;

        // Добавляем импорт в карту
        if (!importMap.has(source)) {
          importMap.set(source, []);
        }
        importMap.get(source).push(importInfo);
      },

      "Program:exit"() {
        checkDuplicateImports();
      }
    };
  }
};

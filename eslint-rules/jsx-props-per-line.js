/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 24, 2025
 */

/**
 * ESLint rule: jsx-props-per-line
 *
 * Проверяет, что JSX-пропсы, расположенные на отдельных строках, отсортированы по длине строки (от коротких к длинным).
 * Проп "key" всегда должен быть первым и отделяться пустой строкой от остальных пропсов.
 *
 * Опции:
 * - ignoreDataAttributes: игнорировать data-* атрибуты при сортировке (по умолчанию false)
 * - ignoreAriaAttributes: игнорировать aria-* атрибуты при сортировке (по умолчанию false)
 */

export default {
  meta: {
    type: "layout",
    docs: {
      description: "Enforce props on new lines when line length exceeds maximum",
      category: "Stylistic Issues",
      recommended: false
    },
    fixable: "whitespace",
    schema: [
      {
        type: "object",
        properties: {
          ignoreDataAttributes: {
            type: "boolean",
            default: false
          },
          ignoreAriaAttributes: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }
    ]
  },

  create(context) {
    const options = context.options[0] || {};
    const ignoreDataAttributes = options.ignoreDataAttributes || false;
    const ignoreAriaAttributes = options.ignoreAriaAttributes || false;
    const sourceCode = context.getSourceCode();

    function getAttributeText(attribute) {
      return sourceCode.getText(attribute);
    }

    function getAttributeName(attribute) {
      if (attribute.type === "JSXAttribute") {
        return attribute.name.name;
      }
      return "";
    }

    function shouldIgnoreAttribute(attributeName) {
      if (attributeName === "key") {
        return true; // key обрабатывается отдельно
      }
      if (ignoreDataAttributes && attributeName.startsWith("data-")) {
        return true;
      }
      if (ignoreAriaAttributes && attributeName.startsWith("aria-")) {
        return true;
      }
      return false;
    }

    function isKeyAttribute(attribute) {
      return getAttributeName(attribute) === "key";
    }

    function hasKeyAttribute(attributes) {
      return attributes.some(attr => isKeyAttribute(attr));
    }

    function getKeyAttribute(attributes) {
      return attributes.find(attr => isKeyAttribute(attr));
    }

    function isKeyFirstAndSeparated(attributes) {
      if (!hasKeyAttribute(attributes)) return true;

      const keyAttr = getKeyAttribute(attributes);
      const keyIndex = attributes.indexOf(keyAttr);

      // key должен быть первым
      if (keyIndex !== 0) return false;

      // Если есть другие атрибуты после key, должна быть пустая строка
      if (attributes.length > 1) {
        const nextAttr = attributes[1];
        const keyEndLine = keyAttr.loc.end.line;
        const nextStartLine = nextAttr.loc.start.line;

        // Между key и следующим атрибутом должна быть как минимум одна пустая строка
        return nextStartLine - keyEndLine >= 2;
      }

      return true;
    }

    function arePropsOnSeparateLines(attributes) {
      if (attributes.length <= 1) return true;

      // Проверяем, что каждый атрибут на своей строке
      for (let i = 1; i < attributes.length; i++) {
        if (attributes[i].loc.start.line === attributes[i - 1].loc.start.line) {
          return false;
        }
      }
      return true;
    }

    function arePropsOrderedByLength(attributes) {
      const sortableAttributes = attributes.filter(attr => {
        const name = getAttributeName(attr);
        return !shouldIgnoreAttribute(name);
      });

      if (sortableAttributes.length <= 1) return true;

      for (let i = 1; i < sortableAttributes.length; i++) {
        const prevLength = getAttributeText(sortableAttributes[i - 1]).length;
        const currentLength = getAttributeText(sortableAttributes[i]).length;

        if (prevLength > currentLength) {
          return false;
        }
      }
      return true;
    }

    return {
      JSXElement(node) {
        const openingElement = node.openingElement;
        const attributes = openingElement.attributes;

        if (attributes.length <= 1) return;

        // Проверяем только если атрибуты уже на отдельных строках
        if (!arePropsOnSeparateLines(attributes)) {
          return; // Пропускаем, если атрибуты на одной строке
        }

        // Проверяем позицию и разделение key атрибута
        const keyIssue = !isKeyFirstAndSeparated(attributes);
        const sortingIssue = !arePropsOrderedByLength(attributes);

        if (keyIssue || sortingIssue) {
          let message = "";
          if (keyIssue && sortingIssue) {
            message = "Prop 'key' should be first and separated by empty line, and other props should be ordered by line length";
          } else if (keyIssue) {
            message = "Prop 'key' should be first and separated by empty line from other props";
          } else {
            message = "Props should be ordered by line length (shortest to longest)";
          }

          context.report({
            node: openingElement,
            message,
            fix(fixer) {
              // Разделяем атрибуты по типам
              const attributeData = attributes.map(attr => ({
                node: attr,
                text: getAttributeText(attr),
                name: getAttributeName(attr),
                isKey: isKeyAttribute(attr),
                shouldIgnore: shouldIgnoreAttribute(getAttributeName(attr)) && !isKeyAttribute(attr)
              }));

              // Разделяем атрибуты на группы
              const keyAttr = attributeData.find(attr => attr.isKey);
              const sortableAttrs = attributeData.filter(attr => !attr.isKey && !attr.shouldIgnore);
              const ignoredAttrs = attributeData.filter(attr => !attr.isKey && attr.shouldIgnore);

              // Сортируем обычные атрибуты по длине
              sortableAttrs.sort((a, b) => a.text.length - b.text.length);

              // Формируем финальный порядок: key первым, потом отсортированные, потом игнорируемые
              const finalOrder = [];
              if (keyAttr) finalOrder.push(keyAttr);
              finalOrder.push(...sortableAttrs);
              finalOrder.push(...ignoredAttrs);

              // Проверяем, нужны ли изменения
              let needsReordering = false;
              let needsKeyFormatting = false;

              // Проверка порядка
              for (let i = 0; i < attributes.length; i++) {
                if (attributes[i] !== finalOrder[i].node) {
                  needsReordering = true;
                  break;
                }
              }

              // Проверка форматирования key
              if (keyAttr && !isKeyFirstAndSeparated(attributes)) {
                needsKeyFormatting = true;
              }

              const fixes = [];

              if (needsReordering || needsKeyFormatting) {
                // Определяем отступы
                const baseIndent = " ".repeat(openingElement.loc.start.column);
                const propIndent = baseIndent + "  ";

                // Собираем новый текст атрибутов
                const newAttributesText = finalOrder.map((attr, index) => {
                  const isFirst = index === 0;
                  const isLast = index === finalOrder.length - 1;
                  const isAfterKey = index === 1 && finalOrder[0].isKey;

                  let prefix = isFirst ? "\n" + propIndent : "\n" + propIndent;

                  // Добавляем пустую строку после key
                  if (isAfterKey) {
                    prefix = "\n\n" + propIndent;
                  }

                  const suffix = isLast ? "\n" + baseIndent : "";
                  return prefix + attr.text + suffix;
                }).join("");

                // Заменяем весь блок атрибутов
                const firstAttr = attributes[0];
                const lastAttr = attributes[attributes.length - 1];
                const start = firstAttr.range[0];
                const end = lastAttr.range[1];

                fixes.push(fixer.replaceTextRange([start, end], newAttributesText.trim()));
              }

              return fixes;
            }
          });
        }
      }
    };
  }
};

/**
 * This file was generated by GitHub Copilot (Claude 3.5 Sonnet)
 * Date: September 26, 2025
 */

/**
 * ESLint rule: no-snake-case (simplified version)
 *
 * Запрещает использование snake_case в именах переменных, функций, свойств и типов,
 * за исключением:
 * - файлов в папке src/shared/values/
 * - элементов типов, содержащих "ApiModel" или "ApiResponse" в названии типа
 * - обращений к свойствам объектов с типами, содержащими "ApiModel" или "ApiResponse"
 */

export default {
    meta: {
        type: "problem",
        docs: {
            description: "Disallow snake_case naming except in specific cases",
            category: "Stylistic Issues",
            recommended: false
        },
        fixable: null,
        schema: [],
        messages: {
            noSnakeCase: "Identifier '{{name}}' uses snake_case. Use camelCase instead.",
            noSnakeCaseType: "Type identifier '{{name}}' uses snake_case. Use PascalCase instead.",
        },
    },

    create(context) {
        const filename = context.getFilename();
        const sourceCode = context.getSourceCode();

        // Проверяем, находится ли файл в папке src/shared/values/
        const isValuesFile = filename.includes('src\\shared\\values\\') || filename.includes('src/shared/values/');

        // Функция для определения, содержит ли файл типы с ApiModel или ApiResponse
        function hasApiTypes() {
            const text = sourceCode.getText();
            return /(?:interface|type|class)\s+\w*(ApiModel|ApiResponse)\w*/g.test(text);
        }

        // Функция для проверки, является ли идентификатор частью ApiModel или ApiResponse типа
        function isPartOfApiType(node) {
            if (!hasApiTypes()) return false;

            let parent = node.parent;
            while (parent) {
                // Проверяем, находится ли свойство внутри интерфейса/типа с ApiModel или ApiResponse в названии
                if (parent.type === 'TSInterfaceDeclaration' || parent.type === 'TSTypeAliasDeclaration') {
                    const typeName = parent.id?.name || '';
                    if (typeName.includes('ApiModel') || typeName.includes('ApiResponse')) {
                        return true;
                    }
                }
                // Проверяем для свойств объектных типов
                if (parent.type === 'TSTypeLiteral') {
                    let typeParent = parent.parent;
                    while (typeParent) {
                        if (typeParent.type === 'TSTypeAliasDeclaration') {
                            const typeName = typeParent.id?.name || '';
                            if (typeName.includes('ApiModel') || typeName.includes('ApiResponse')) {
                                return true;
                            }
                        }
                        typeParent = typeParent.parent;
                    }
                }
                parent = parent.parent;
            }
            return false;
        }

        // Упрощенная функция для проверки объектных литералов с API типами
        function isApiObjectLiteral(node) {
            const fullText = sourceCode.getText();
            const hasApiTypesInFile = hasApiTypes();
            const hasCoreImports = /@app\/core/.test(fullText);

            if (!hasApiTypesInFile && !hasCoreImports) return false;

            // Проверяем, что это свойство объектного литерала
            if (node.parent?.type !== 'Property' || node.parent.key !== node) {
                return false;
            }

            // Поднимаемся к ObjectExpression
            let current = node.parent.parent;
            if (current?.type !== 'ObjectExpression') {
                return false;
            }

            // Проверяем, передается ли объект в API функцию
            let callExpression = current.parent;
            if (callExpression?.type === 'CallExpression') {
                const funcName = callExpression.callee?.name;
                // Проверяем стандартные API функции
                if (['get', 'post', 'put', 'delete', 'patch'].includes(funcName)) {
                    return true;
                }
            }

            // Простая проверка: ищем в тексте строки с объявлением переменной, содержащие ApiModel/ApiResponse
            let variableDeclarator = current.parent;
            if (variableDeclarator?.type === 'VariableDeclarator') {
                // Получаем текст строки с объявлением переменной
                const startLine = variableDeclarator.loc.start.line;
                const endLine = variableDeclarator.loc.end.line;
                const lines = sourceCode.getText().split('\n');

                for (let i = startLine - 1; i < endLine; i++) {
                    const line = lines[i] || '';
                    if (/(ApiModel|ApiResponse)/.test(line)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Функция для проверки, является ли доступ к свойству объекта с API типом
        function isApiObjectProperty(node) {
            // Получаем текст всего файла для проверки импортов
            const fullText = sourceCode.getText();

            // Проверяем, есть ли в файле API типы или импорты из @app/core
            const hasApiTypesInFile = hasApiTypes();
            const hasCoreImports = /@app\/core/.test(fullText);

            if (!hasApiTypesInFile && !hasCoreImports) return false;

            // Проверяем MemberExpression (например, response.expiration_date)
            if (node.parent?.type === 'MemberExpression' && node.parent.property === node) {
                const objectName = node.parent.object?.name;
                if (!objectName) return false;

                // Ищем функцию, содержащую этот код
                let current = node.parent;
                while (current && current.type !== 'FunctionDeclaration' &&
                    current.type !== 'ArrowFunctionExpression' &&
                    current.type !== 'FunctionExpression') {
                    current = current.parent;
                }

                if (current) {
                    const funcText = sourceCode.getText(current);

                    // Случай 1: простое присваивание с await (response = await get<ApiModel>)
                    const apiTypeRegex = new RegExp(`${objectName}\\s*=\\s*await\\s+\\w+<(\\w*(ApiModel|ApiResponse)\\w*)>`);
                    const match = funcText.match(apiTypeRegex);
                    if (match) {
                        return true;
                    }

                    // Случай 1.5: присваивание результата любой функции в файле с API типами
                    // Если файл содержит API типы, то скорее всего все await вызовы функций возвращают API объекты
                    // Учитываем возможные скобки: (await func())
                    const awaitCallRegex = new RegExp(`${objectName}\\s*=\\s*\\(?await\\s+\\w+\\(`);
                    if (awaitCallRegex.test(funcText)) {
                        return true;
                    }

                    // Случай 1.6: деструктуризация объекта из API вызова
                    // Паттерн: const { prop1, prop2 } = await apiCall<ApiType>()
                    // Поддерживаем многострочную деструктуризацию
                    const destructRegex = new RegExp(`{[\\s\\S]*?\\b${objectName}\\b[\\s\\S]*?}\\s*=\\s*await\\s+\\w+`);
                    if (destructRegex.test(funcText)) {
                        return true;
                    }

                    // Случай 1.7: деструктуризация из переменной, полученной из API
                    // Паттерн: const { result } = apiResult; где apiResult = await api()
                    const varDestructRegex = new RegExp(`{[\\s\\S]*?\\b${objectName}\\b[\\s\\S]*?}\\s*=\\s*(\\w+)`);
                    const varMatch = funcText.match(varDestructRegex);
                    if (varMatch) {
                        const sourceVar = varMatch[1];
                        // Проверяем, что sourceVar получен из API вызова
                        const sourceApiRegex = new RegExp(`${sourceVar}\\s*=\\s*await\\s+\\w+`);
                        if (sourceApiRegex.test(funcText)) {
                            return true;
                        }
                    }

                    // Случай 2: параметр функции map для массива API-типов
                    // Ищем паттерн: .map(x => ...) где x.property и есть вызов get<Array<ApiModel>>
                    if (current.type === 'ArrowFunctionExpression') {
                        // Проверяем, является ли objectName параметром этой arrow function
                        const params = current.params;
                        const paramWithType = params.find(param => param.name === objectName);

                        if (paramWithType) {
                            // Проверяем явную типизацию параметра
                            if (paramWithType.typeAnnotation?.typeAnnotation?.typeName?.name) {
                                const paramTypeName = paramWithType.typeAnnotation.typeAnnotation.typeName.name;
                                if (paramTypeName.includes('ApiModel') || paramTypeName.includes('ApiResponse')) {
                                    return true;
                                }
                            }

                            // Ищем родительский CallExpression (.map(...))
                            let mapCall = current.parent;
                            while (mapCall && mapCall.type !== 'CallExpression') {
                                mapCall = mapCall.parent;
                            }

                            if (mapCall && mapCall.callee?.property?.name === 'map') {
                                // Ищем в более широком контексте вызов с API типом массива
                                let funcContainer = mapCall;
                                while (funcContainer && funcContainer.type !== 'FunctionDeclaration' &&
                                    funcContainer.type !== 'ArrowFunctionExpression' &&
                                    funcContainer.type !== 'FunctionExpression') {
                                    funcContainer = funcContainer.parent;
                                }

                                if (funcContainer) {
                                    const containerText = sourceCode.getText(funcContainer);
                                    // Ищем get<Array<ApiModel>> или get<ApiModel[]>
                                    const arrayApiRegex = /get<(?:Array<)?(\w*(ApiModel|ApiResponse)\w*)(?:\[\]|>)/g;
                                    if (arrayApiRegex.test(containerText)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Случай 3: деструктуризация в параметрах callback функций (.then, .map и т.д.)
            // Упрощенная проверка: если файл содержит API типы/импорты и мы в arrow function с деструктуризацией
            if ((hasApiTypesInFile || hasCoreImports)) {
                let current = node;
                let isInArrowFunction = false;
                let isInDestructuring = false;
                let callbackMethodName = null;

                // Поднимаемся по AST
                while (current && current.parent) {
                    current = current.parent;

                    // Проверяем деструктуризацию в параметре
                    if (current.type === 'ObjectPattern') {
                        isInDestructuring = true;
                    }

                    // Проверяем arrow function
                    if (current.type === 'ArrowFunctionExpression' && isInDestructuring) {
                        isInArrowFunction = true;
                    }

                    // Проверяем вызов .then или .map
                    if (current.type === 'CallExpression' && isInArrowFunction) {
                        callbackMethodName = current.callee?.property?.name;
                        if (callbackMethodName === 'then' || callbackMethodName === 'map') {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        function hasSnakeCase(name) {
            return /_/.test(name) && name !== name.toUpperCase(); // исключаем CONSTANTS
        }

        /**
         * Проверяет, была ли переменная получена из API деструктуризации
         * @param {Object} node - узел AST
         * @param {string} varName - имя переменной
         * @returns {boolean}
         */
        function isVariableFromApiDestructuring(node, varName) {
            // Найдем функцию, содержащую этот узел
            let functionNode = node;
            while (functionNode && functionNode.type !== "FunctionDeclaration" &&
                functionNode.type !== "FunctionExpression" &&
                functionNode.type !== "ArrowFunctionExpression") {
                functionNode = functionNode.parent;
            }

            if (!functionNode) {
                return false;
            }

            const funcText = sourceCode.getText(functionNode);

            // Случай 1: Ищем паттерн деструктуризации с данной переменной
            // Паттерн: const { ..., varName, ... } = await someFunction(...)
            const destructRegex = new RegExp(`{[\\s\\S]*?\\b${varName}\\b[\\s\\S]*?}\\s*=\\s*await\\s+\\w+`);
            if (destructRegex.test(funcText)) {
                return true;
            }

            // Случай 2: Деструктуризация в параметрах callback функций
            // Проверяем, является ли эта переменная параметром деструктуризации в arrow function
            if (functionNode.type === 'ArrowFunctionExpression') {
                const params = functionNode.params;
                for (const param of params) {
                    if (param.type === 'ObjectPattern') {
                        const properties = param.properties;
                        for (const prop of properties) {
                            if (prop.type === 'Property' && prop.key?.name === varName) {
                                // Проверяем, что эта arrow function передается в .then или .map
                                let callExpr = functionNode.parent;
                                if (callExpr && callExpr.type === 'CallExpression') {
                                    const methodName = callExpr.callee?.property?.name;
                                    if (methodName === 'then' || methodName === 'map') {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        function checkIdentifier(node, isType = false) {
            const name = node.name;

            if (!hasSnakeCase(name)) return;

            // Пропускаем для файлов в shared/values
            if (isValuesFile) return;

            // Получаем информацию о файле для проверки API контекста
            const fullText = sourceCode.getText();
            const hasApiTypesInFile = hasApiTypes();
            const hasCoreImports = /@app\/core/.test(fullText);

            // Пропускаем для элементов ApiModel и ApiResponse типов
            if (isPartOfApiType(node)) return;

            // Пропускаем для свойств в объектных литералах с API типами
            if (isApiObjectLiteral(node)) return;

            // Пропускаем для доступа к свойствам объектов с API типами
            if (isApiObjectProperty(node)) return;

            // Пропускаем деструктуризацию из API вызовов
            if (node.parent?.type === 'Property' && node.parent.key === node && node.parent.parent?.type === 'ObjectPattern') {
                // Проверяем, является ли это деструктуризацией из API вызова
                const destructuringPattern = node.parent.parent;
                if (destructuringPattern.parent?.type === 'VariableDeclarator' && destructuringPattern.parent.init) {
                    const init = destructuringPattern.parent.init;

                    // Проверяем await вызов в файлах с API типами или core импортами
                    if (init.type === 'AwaitExpression' && (hasApiTypesInFile || hasCoreImports)) {
                        return;
                    }
                }
            }

            // Пропускаем переменные, полученные из API деструктуризации
            if ((hasApiTypesInFile || hasCoreImports) && isVariableFromApiDestructuring(node, name)) {
                return;
            }

            context.report({
                node,
                messageId: isType ? "noSnakeCaseType" : "noSnakeCase",
                data: { name }
            });
        }

        return {
            // Переменные и функции
            Identifier(node) {
                // Пропускаем типы - они обрабатываются отдельно
                if (node.parent?.type === 'TSInterfaceDeclaration' ||
                    node.parent?.type === 'TSTypeAliasDeclaration' ||
                    node.parent?.type === 'TSEnumDeclaration') {
                    return;
                }

                checkIdentifier(node, false);
            },

            // Интерфейсы и типы
            TSInterfaceDeclaration(node) {
                checkIdentifier(node.id, true);
            },

            TSTypeAliasDeclaration(node) {
                checkIdentifier(node.id, true);
            },

            TSEnumDeclaration(node) {
                checkIdentifier(node.id, true);
            },

            // Свойства типов и интерфейсов
            TSPropertySignature(node) {
                if (node.key?.type === 'Identifier') {
                    checkIdentifier(node.key, false);
                }
            },

            // Свойства в объектах
            Property(node) {
                if (node.key?.type === 'Identifier' && !node.computed && !node.shorthand) {
                    checkIdentifier(node.key, false);
                }
            }
        };
    }
};
